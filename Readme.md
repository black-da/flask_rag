# 需求：

* 用langchain实现rag，rag的功能包括： 
  * 知识库的增删改查 
  * 某个知识库下文件的增删改查 
  * 对话（支持调节命中后topk作为提示词） 
* 知识库概念：
  * 一个知识库下面可以有多个文件；
  * 每个知识库之间相互独立；
  * 用户提问的时候可以指定知识库

# 知识库形式

* 每个知识库对应一个文件夹，文件夹里全部是txt文件

# 向量数据库设计

* 用chroma向量数据库

* 每个知识库对应一个collection，collection_name就是知识库的名称

* 向量数据库api：

  * 创建向量数据库：

    ```
    Chroma.from_documents(docs, embeddings_model, collection_name=collection_name,
                          persist_directory=persist_directory)
    ```

  * 加载存储在硬盘的向量数据库：

    ```
    db = Chroma(
        collection_name=collection_name,
        embedding_function=embeddings_model,
        persist_directory=persist_directory,
    )
    ```

  * 向量数据库的增删改查：

    ```python
    # 删除数据库中这个集合，在这里，一个集合代表一个知识库
    db.delete_collection()  
    
    # 修改集合名字
    persistent_client = chromadb.PersistentClient(path=persist_directory)
        collection = persistent_client.get_or_create_collection(collection_name)
        collection.modify(name=new_name)
        
    # 删除集合中的记录，file_name是存储在metadata里的
    db = get_db(persist_directory, embeddings_model, collection_name)
        for file_name in file_names:
            ids = db.get(where={'file_name': file_name}).get('ids')  # 通过metadata过滤出指定记录
            db.delete(ids=ids)  # 调用数据库api删除记录
    ```

    

# 功能实现

## 知识库的增删改查

### 增

1. 用户给知识库一个名称，再上传多个txt文件作为知识库的文件

2. 后台创建一个文件夹，文件夹里下载用户上传的文件

3. 在向量数据库中给这个知识库创建一个collection，collection_name为知识库名字，并对这个知识库进行文本嵌入，文本嵌入时通过matedata标明生成的document来自哪个文件

   

### 删

1. 用户输入要删除的知识库

2. 后台通过collection_name删除对应的collection，再删除知识库对应的文件夹和文件

   

### 改

1. 用户输入新的知识库名称和旧的知识库名称
2. 后台拿到新旧知识库名称并修改，先修改向量数据库里的collection_name，再修改文件夹名字

### 查

1. 查看有哪些知识库：
   1. 返回文件夹名称的列表
2. 查看指定知识库里有哪些文件：
   1. 用户输入要查询的知识库名称
   2. 后台返回对应名称的文件夹的文件名称列表



## 某个知识库下文件的增删改查 

### 前提

* 用户输入要操作的知识库名称

### 增

* 用户上传文件
* 后台先在文件夹中下载文件，再在数据库中添加文件

### 删

* 用户输入要删除的文件名称
* 先根据metadata删数据库里的内容，再删除文件夹中的文件

### 改

* 用户修改后上传新文件的名称和内容
* 后台修删掉知识库里的旧文件（调用删除文件接口），再增加新文件（调用新增文件接口）

### 查

* 用户输入文件名称，后台返回对应文件内容的字符串



### 对话

1. 先让用户选择知识库，提出问题，以及输入参数k选择他们要参考topk的相关片段得出的答案
2. 根据知识库的名字得知collection_name，从而构造出向量数据库对象
3. 由向量数据库对象构造检索器，并得到和用户提问相关性最大的前k个document，将他们填充到提示词模板中。提示词模板考虑对话记录
4. 将提示词传递给大模型，由大模型生成答案并返回



# 接口设计

采用restful接口设计方式：

* 知识库接口：route('/knowledge_bases/', methods=['GET', 'POST', 'PUT', 'DELETE'])，分别代表知识库的增删改查
* 知识库下文件的接口：rule：'/knowledge_base_files/'。谓词同上
* 对话接口:rule: /chat/



# bug记录

* 在使用db.get(where={'metadata_filed': value})方法过滤数据时

  * 首先是使用id过滤的问题，get的源码中提供了关键字参数ids过滤记录，但那个ids输入的应该是切片后的Document的id，而这个id是数据库自动生成的无规则的，而不是简单的1,2,3这样的数字
  * 其次是那个metadata的问题，那个metadata一开始我用的是自动生成的{'source': file_path}的字段，但是里面的file_path里的地址分隔符\在python的字符串里被解释为转义了，所以查不到。经过字符串处理后才能查到。而且最好我们在加载文档的时候自己设置一些用于记录文档信息的metadata。具体的添加方法直接操作`Document.metadata`属性即可，它是一个dict

* 关于模型本身预训练得到的知识与参考知识的优先级。在这个项目中，我只上传了java的面试资料，然后问模型python是什么，模型也可以给出正确的回答。关于这个问题，可以通过更改提示词来得到控制。

  * 这个提示词:

    ```python
    template = """使用以下上下文来回答最后的问题。如果你不知道答案，就说你不知道，不要试图编造答
                    案。最多使用三句话。尽量使答案简明扼要。总是在回答的最后说“谢谢你的提问！”。
                    {context}
                    问题: {question}
                    有用的回答:
    """
    
    问到python的问题的回答是：抱歉，提供的文档内容主要讨论的是Java，没有关于Python的信息。谢谢你的提问！
    ```

  * 这个提示词：

    ```python
    template = """你是一个问答任务的助手。
        只能根据以下检索到的上下文片段来回答这个问题，不要带有其他自己的答案。
        如果你不知道答案，就直接说不知道。
        尽量保持答案简洁。
        Question: {question}
        Context: {context}
        Answer:
        """
    问到python的问题的回答是： Python是一种高级编程语言，以简洁明了的语法和强大的库支持而知名。它支持面向对象、命令式、函数式以及元编程等多种编程范式。Python强调代码的可读性和简洁的代码结构，这使得它在教育和科研领域广泛应用。此外，Python还具有良好的跨平台性，可以在Windows、Linux、MacOS等不同操作系统上运行。通过虚拟环境（如Anaconda）和包管理工具（如pip），Python可以方便地管理依赖关系，使得代码在不同环境下保持一致的运行效果。
    ```

  * 可见大模型的提示词是很重要，也很奇妙的。说实话，我自己来看，这两个提示词表达的意思差别不大，可是在模型上产生的效果截然不同。第一个提示词是在github的一个项目中截取出来的：`https://github.com/logan-zou/Chat_with_Datawhale_langchain`csdn。第二个提示词是在csdn的一篇博客找的

* 指定k很重要。当k比较小时，由于采用作为上下文的文档切片比较少以及检索器计算相似性算法的特性，可能导致无法获得有效的与用户问题相关的文档切片填入提示词模板中，进而导致模型的回答效果不好。当k比较大时，提示词中得到的文档切片内容比较多，得到有效信息的可能性也大，回答效果也会更好一些。比如针对**介绍一下数据库中的事务**这个问题。从下面的回答来看，似乎k越大越好
  k=1的情况：

  ```python
  {
  	"answer": " 对不起，我无法在给定的上下文中找到与数据库中的事务相关的信息。谢谢你的提问！",
  	"code": 200,
  	"message": "",
  	"relevant_data": "– 共享存储（使用同步互斥工具操作共享空间）\n– 消息传递（进程间以格式化的消息进行数据交换，有中间实体，分为直接和间接两种，底层通过发送消息和接收消息两个原语实现）\n– 管道通信（两个进程中间存在一个特殊的管道文件，进程的输入输出都通过管道，半双工通信）\nQ：管程是什么？\n由一组数据及对这组数据操作的定义组成的模块。同一时间只能有一个进程使用管程，即管程是互斥使用的，进程释放管程后需唤醒申请管程资源的等待队列上的进程。进程只有通过进入管程并使用管程内部的操作才能访问其中数据",
  	"result": "success"
  }
  ```

  k=4的情况：

  ```python
  {
  	"answer": " 事务是数据库操作的逻辑单位，它包含一系列数据库操作，这些操作要么全部成功，要么全部失败，以确保数据的一致性。事务有四个重要特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。谢谢你的提问！",
  	"code": 200,
  	"message": "",
  	"relevant_data": "– 共享存储（使用同步互斥工具操作共享空间）\n– 消息传递（进程间以格式化的消息进行数据交换，有中间实体，分为直接和间接两种，底层通过发送消息和接收消息两个原语实现）\n– 管道通信（两个进程中间存在一个特殊的管道文件，进程的输入输出都通过管道，半双工通信）\nQ：管程是什么？\n由一组数据及对这组数据操作的定义组成的模块。同一时间只能有一个进程使用管程，即管程是互斥使用的，进程释放管程后需唤醒申请管程资源的等待队列上的进程。进程只有通过进入管程并使用管程内部的操作才能访问其中数据",
  	"result": "success"
  }
  ```

  k=10的情况：

  ```python
  {
  	"answer": " 数据库事务是数据库运行中的逻辑工作单位，包含一系列操作，要求这些操作要么全部执行，要么都不执行，确保数据的一致性。事务具有原子性、一致性、隔离性和持久性四个特性，简称ACID。原子性保证操作的完整性，一致性保证数据状态正确，隔离性防止并发操作的干扰，持久性确保提交的更新不因故障丢失。",
  	"code": 200,
  	"message": "",
  	"relevant_data": "– 共享存储（使用同步互斥工具操作共享空间）\n– 消息传递（进程间以格式化的消息进行数据交换，有中间实体，分为直接和间接两种，底层通过发送消息和接收消息两个原语实现）\n– 管道通信（两个进程中间存在一个特殊的管道文件，进程的输入输出都通过管道，半双工通信）\nQ：管程是什么？\n由一组数据及对这组数据操作的定义组成的模块。同一时间只能有一个进程使用管程，即管程是互斥使用的，进程释放管程后需唤醒申请管程资源的等待队列上的进程。进程只有通过进入管程并使用管程内部的操作才能访问其中数据",
  	"result": "success"
  }
  ```

  从这个例子中的相似性数据可知，我们人类所认为的最接近的文档，在相似性算法之下，可能不是最接近的。即**我们认为的相似性与相似性算法得出的相似性的结果可能有很大的出入**。





